---
name: organize-dependencies
description: タスクの依存関係を並列実行可能な構造で整理する。「依存関係整理して」「DAG整理して」「タスクの順序決めて」で使用。
---

# タスク依存関係の整理（仕様駆動）

<context>
このスキルは**仕様駆動開発（SDD）**の考え方に基づき、
プロジェクトの仕様書・設計書を理解した上で、
タスク間の依存関係を並列実行可能な構造（DAG）で整理する。

**重要**: 依存関係は「なんとなく」ではなく、
仕様に基づいた論理的な根拠を持って決定する。
</context>

## いつ使うか

- 「依存関係整理して」「DAG整理して」と言われた時
- 新しいプロジェクトのタスクを構造化する時
- 仕様書からタスクの実行順序を導き出す時
- 並列実行可能なタスクを特定したい時

## いつ使わないか

- 仕様書がない状態 → 先に仕様を作成
- 単一タスクの実装 → `/implement-tdd`
- タスクの作成 → `/creating-issues`

---

## フロー

<steps>
1. **仕様書・設計書を読む**（最重要）
   - PRD（Product Requirements Document）
   - 技術設計書
   - Issue本文のUser Story / AC
   - docs/ 配下のドキュメント

2. **タスク一覧を取得**
   - MCPでプロジェクトのタスクを取得
   - 各タスクの説明文も確認

3. **仕様からタスク間の関係を分析**
   - どのタスクがどの仕様を実現するか
   - 技術的な依存関係（DB→API→UI）
   - 論理的な依存関係（認証→認証が必要な機能）

4. **並列構造を設計**
   - 同時に着手可能なタスクを特定
   - マージポイント（複数の依存先）を特定

5. **既存の依存関係をクリア**

6. **新しい依存関係を作成**

7. **結果をユーザーに報告**（根拠付き）
</steps>

---

## 仕様書の読み方

### 1. PRD / 要件定義書

```markdown
## 機能要件
- FR-1: ユーザー認証
- FR-2: タスク管理
- FR-3: レポート出力
```

→ FR-1 が FR-2, FR-3 の前提条件かどうかを判断

### 2. Issue本文のUser Story

```markdown
## User Story
As a ユーザー,
I want タスクの依存関係を可視化したい,
So that 実行順序を把握できる

## AC（受け入れ条件）
### AC1: DAG表示
- Given タスクが存在する
- When DAGビューを開く
- Then 依存関係がグラフで表示される
```

→ AC から必要な機能を逆算し、タスクの依存関係を導出

### 3. 技術設計書

```markdown
## アーキテクチャ
1. DBスキーマ設計
2. API設計
3. フロントエンド設計
```

→ 技術レイヤーの依存関係を特定（DB → API → Frontend）

---

## 依存関係の判定基準

### 仕様に基づく依存（最優先）

| 仕様の記述 | 依存関係 |
|-----------|---------|
| 「Aの完了後にBを実行」 | B depends on A |
| 「AはBを前提とする」 | A depends on B |
| 「AとBは独立して実装可能」 | 依存関係なし（並列可） |
| 「AのAPIをBのUIで使用」 | B depends on A |

### 技術的な依存

| 前提タスク | 依存タスク | 根拠 |
|-----------|-----------|------|
| DBテーブル作成 | CRUD API | テーブルがないとAPIが動かない |
| API実装 | フロントエンド | APIがないとUIが動かない |
| 型定義 | 型を使うコード | 型がないとコンパイルエラー |
| 認証機能 | 認証が必要な機能 | 認証なしでは動作しない |

### 並列実行可能なケース

| タスクA | タスクB | 根拠 |
|--------|--------|------|
| バックエンドAPI | フロントエンドモック | 別レイヤー・契約駆動開発 |
| 機能Aの実装 | 機能Bの実装 | 仕様上独立した機能 |
| 単体テスト作成 | E2Eテスト設計 | 並行作業可能 |

---

## 仕様から依存関係を導出する例

### 仕様書の例

```markdown
# DAG可視化機能

## 概要
タスク間の依存関係をDAG（有向非巡回グラフ）で可視化する。

## 機能要件
1. タスク依存関係の保存（task_dependencies テーブル）
2. 依存関係CRUD API
3. React Flowでの可視化
4. 自動レイアウト（dagre）

## 技術スタック
- Backend: Rust (Axum) + SQLite
- Frontend: React + React Flow
- 共有型: ts-rs
```

### 導出された依存関係

```
Phase 1: 基盤
  1-1: DBテーブル作成 ←── 仕様「依存関係の保存」より

Phase 2: API（1-1に依存）
  1-2: DAG位置フィールド ←── 仕様「可視化」の位置保存要件
  1-3: CRUD API ←── 仕様「依存関係CRUD API」より

  → 1-2と1-3は並列可能（両方1-1に依存、互いは独立）

Phase 3: 型定義（1-2, 1-3に依存）
  1-4: TypeScript型生成 ←── 仕様「共有型: ts-rs」より

  → 1-2と1-3の両方が完了しないと型が不完全

Phase 4: フロントエンド（1-4に依存）
  2-1: React Flow導入 ←── 仕様「React Flowでの可視化」より
  2-2: TaskNode ←── 2-1に依存
  2-3: ドラッグ&ドロップ ←── 2-2に依存
  2-4: dagre自動レイアウト ←── 仕様「自動レイアウト」より、2-1に依存

  → 2-2と2-4は並列可能（両方2-1に依存）
```

### 結果のDAG

```
             ┌─→ 1-2 ─┐
    1-1 ─────┤        ├─→ 1-4 ─→ 2-1 ─┬─→ 2-2 ─→ 2-3 ─┐
             └─→ 1-3 ─┘               └─→ 2-4 ────────┼─→ 完了
```

---

## MCPツール使用方法

### タスク一覧取得

```
mcp__vibe_kanban__list_tasks
  project_id: <プロジェクトID>
```

### タスク詳細取得（説明文確認）

```
mcp__vibe_kanban__get_task
  task_id: <タスクID>
```

### 依存関係作成

```bash
curl -X POST "http://localhost:<port>/api/projects/<project_id>/dependencies" \
  -H "Content-Type: application/json" \
  -d '{"task_id": "<依存するタスク>", "depends_on_task_id": "<前提タスク>"}'
```

---

## 出力形式

<output_format>
```markdown
## 依存関係整理完了

### 参照した仕様

| ドキュメント | 内容 |
|-------------|------|
| docs/xxx.md | 機能要件定義 |
| Issue #XX | User Story と AC |

### タスクと仕様の対応

| タスク | 実現する仕様 |
|--------|-------------|
| 1-1: DBテーブル作成 | FR-1: データ永続化 |
| 1-3: CRUD API | FR-2: API提供 |

### 依存関係グラフ

```
        ┌─→ B ─┐
    A ──┤      ├─→ D
        └─→ C ─┘
```

### 依存関係の根拠

| 依存関係 | 根拠 |
|---------|------|
| B depends on A | 仕様「Aの完了後にB」より |
| C depends on A | 技術依存: DBがないとAPIが動かない |
| D depends on B, C | 仕様「B, Cの統合」より |

### 並列実行可能なタスク

| レベル | タスク | 根拠 |
|--------|--------|------|
| 1 | B, C | 仕様上独立した機能 |

合計: X件の依存関係を作成しました。
```
</output_format>

---

## 重要

<important>
- **仕様書を必ず読む**: 依存関係は仕様から導出する
- **根拠を明記する**: なぜその依存関係なのかを説明
- **並列可能を積極的に探す**: Git Worktreeの利点を活かす
- **循環依存に注意**: 仕様の矛盾を発見したら報告
- **ACを確認**: 受け入れ条件からタスクの完了条件を把握
</important>

---

## 仕様書がない場合

<fallback>
仕様書がない場合は、以下の順で情報を収集:

1. **タスクの説明文**を読み、目的を理解
2. **コードベース**を調査し、技術的な依存を特定
3. **ユーザーに確認**: 「このタスクはどのタスクの後に実行すべきですか？」

ただし、仕様書なしの依存関係整理は**推測に基づく**ため、
ユーザーに確認を取りながら進める。
</fallback>

---

## 次のステップ

<next_step>
依存関係整理後:
1. DAGビューで視覚的に確認
2. ユーザーに依存関係の妥当性を確認
3. 問題があれば仕様書を見直し
4. 各タスクの実装は `/implement-tdd` で
</next_step>
